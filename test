package edu.kit.informatik;

public class UnionSortedIterator<T extends Comparable<T>> implements SortedIterator<T> {

    private SortedIterator<T> iteratorA, iteratorB;
    private T currentOfIteratorA, currentOfIteratorB;

    /**
     * Constructor
     *
     * @param iteratorA first iterator
     * @param iteratorB second iterator
     */
    public UnionSortedIterator(SortedIterator<T> iteratorA, SortedIterator<T> iteratorB) {
        this.iteratorA = iteratorA;
        this.iteratorB = iteratorB;
        currentOfIteratorA = null;
        currentOfIteratorB = null;
    }

    @Override
    public boolean hasNext() {
        if (iteratorA.hasNext() || iteratorB.hasNext()) {
            return true;
        }
        return false;
    }

    @Override
    public T next() {

        //No Element first step
        if (currentOfIteratorA == null && currentOfIteratorB == null) {
            currentOfIteratorA = iteratorA.next();
            currentOfIteratorB = iteratorB.next();
            return CompareElement();
        }

        //if we finish iterator b before a
        T currentAOfIteratorTmp1 = handleIteratorAIfIteratorBIsEmpty();
        if (currentAOfIteratorTmp1 != null) return currentAOfIteratorTmp1;

        //if we finish iterator a before b
        T currentBOfIteratorTmp1 = handleIteratorBIfIteratorAIsEmpty();
        if (currentBOfIteratorTmp1 != null) return currentBOfIteratorTmp1;


        //All other cases
        return CompareElement();

    }

    private T handleIteratorAIfIteratorBIsEmpty() {
        if (currentOfIteratorA != null && !iteratorB.hasNext()) {
            T currentOfIteratorTmp;
            if(iteratorA.hasNext() && currentOfIteratorB == null){
                currentOfIteratorB = iteratorA.next();
                if(!iteratorA.hasNext()){
                    return currentOfIteratorB;
                }
                currentOfIteratorTmp = CompareElementWithoutNext();
            }else{
                currentOfIteratorTmp = CompareElementWithoutNext();
                currentOfIteratorB= null;
            }
            return currentOfIteratorTmp;
        }
        return null;
    }

    private T handleIteratorBIfIteratorAIsEmpty() {
        //if we finish iterator A before
        if (currentOfIteratorB != null && !iteratorA.hasNext()) {
            T currentOfIteratorTmp;
            if(iteratorA.hasNext() && currentOfIteratorA == null){
                currentOfIteratorA = iteratorB.next();
                if(!iteratorB.hasNext()){
                    return currentOfIteratorA;
                }
                currentOfIteratorTmp = CompareElementWithoutNext();
            }else{
                currentOfIteratorTmp = CompareElementWithoutNext();
                currentOfIteratorA= null;
            }
            return currentOfIteratorTmp;
        }
        return null;
    }


    private T CompareElement() {
        T currentOfIteratorATmp;
        T currentOfIteratorBTmp;
        if (currentOfIteratorA.compareTo(currentOfIteratorB) < 0) {
            currentOfIteratorATmp = currentOfIteratorA;
            currentOfIteratorA = iteratorA.next();
            return currentOfIteratorATmp;
        } else {
            currentOfIteratorBTmp = currentOfIteratorB;
            currentOfIteratorB = iteratorB.next();
            return currentOfIteratorBTmp;
        }
    }

    private T CompareElementWithoutNext() {
        T currentOfIteratorATmp;
        T currentOfIteratorBTmp;
        if (currentOfIteratorA.compareTo(currentOfIteratorB) < 0) {
            currentOfIteratorATmp = currentOfIteratorA;
            currentOfIteratorA = currentOfIteratorB;
            return currentOfIteratorATmp;
        } else {
            currentOfIteratorBTmp = currentOfIteratorB;
            currentOfIteratorB = currentOfIteratorA;
            return currentOfIteratorBTmp;
        }
    }





}

